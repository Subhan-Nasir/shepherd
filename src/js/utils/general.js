import { element } from 'svelte/internal';
import { isElement, isFunction, isHTMLElement, isString } from './type-check';

/**
 * Ensure class prefix ends in `-`
 * @param {string} prefix The prefix to prepend to the class names generated by nano-css
 * @return {string} The prefix ending in `-`
 */
export function normalizePrefix(prefix) {
    if (!isString(prefix) || prefix === '') {
        return '';
    }

    return prefix.charAt(prefix.length - 1) !== '-' ? `${prefix}-` : prefix;
}

/**
 * Resolves attachTo options, converting element option value to a qualified HTMLElement.
 * @param {Object} step The step instance
 * @returns {[] | ResolvedAttachToOption[]}
 * `element` is a qualified HTML Element
 * `on` is a string position value
 */
export function parseAttachTo(step) {

    const optionsList = step.options.attachTo || [];

    /** @type { ResolvedAttachToOption[]} */
    const returnOptsList = [];

    optionsList.forEach((/** @type {AttachToOption} */ options) => {

        if(!options){
            return;
        }

        /*** @type {HTMLElement | null} */
        let el = null;

        if(isFunction(options.element)){
            el = options.element.call(step);
        } else if(isString(options.element)){
            try {
                el = /**@type {HTMLElement} */ (document.querySelector(options.element));
            } catch (e) {
                // TODO
            }
        } else if(isElement(options.element)) {
            el = /**@type {HTMLElement} */ (options.element);
        } else if(isHTMLElement(options.element)) {
            el = options.element;
        }

        if(!el){ return }

        let attachObj = {element: el}
        if(options.on){
            attachObj.on = options.on;
        }

        returnOptsList.push(attachObj)

    });


    return returnOptsList




    // const options = step.options.attachTo || {};
    // const returnOpts = Object.assign({}, options);

    // if (isFunction(returnOpts.element)) {
    //     // Bind the callback to step so that it has access to the object, to enable running additional logic
    //     returnOpts.element = returnOpts.element.call(step);
    // }

    // if (isString(returnOpts.element)) {
    //     // Can't override the element in user opts reference because we can't
    //     // guarantee that the element will exist in the future.
    //     try {
    //         returnOpts.element = document.querySelector(returnOpts.element);
    //     } catch (e) {
    //         // TODO
    //     }
    //     if (!returnOpts.element) {
    //         console.error(
    //             `The element for this Shepherd step was not found ${options.element}`
    //         );
    //     }
    // }

    // console.log("PARSE ATTACH TO - RETURN OPTS: ");
    // console.log(returnOpts);

    // return returnOpts;
}

/**
 * Checks if the step should be centered or not. Does not trigger attachTo.element evaluation, making it a pure
 * alternative for the deprecated step.isCentered() method.
 * @param {object} resolvedAttachToOptions
 * @returns {boolean}
 */
export function shouldCenterStep(resolvedAttachToOptions) {
    if (
        resolvedAttachToOptions === undefined ||
        resolvedAttachToOptions === null || 
        resolvedAttachToOptions.length === 0
    ) {
        return true;
    }

    let attachableElementExists = resolvedAttachToOptions.some(attachTo => {
        if(attachTo.element && attachTo.on){
            return true;
        }

        return false;
    })

    // Don't center if tooltip can be attached to an element
    return !attachableElementExists;
}

/**
 * Create a unique id for steps, tours, modals, etc
 * @return {string}
 */
export function uuid() {
    let d = Date.now();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
        const r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);
    });
}
